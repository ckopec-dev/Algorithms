# Cocke-Younger-Kasami (CYK) Parsing Algorithm

The CYK algorithm is a dynamic programming algorithm for parsing context-free grammars in Chomsky Normal Form (CNF). It determines whether a string can be generated by a given grammar and constructs a parse tree.

## Python Implementation

```python
def cyk_parse(grammar, sentence):
    """
    Parse a sentence using the CYK algorithm
    
    Args:
        grammar: Dictionary with 'rules' key containing list of rules
                 Each rule is a tuple (non_terminal, [terminal_or_nonterminal1, ...])
        sentence: List of terminals to parse
    
    Returns:
        Boolean indicating if sentence can be parsed, and parse table
    """
    
    # Extract grammar rules
    rules = grammar['rules']
    
    # Convert grammar to CNF format
    cnf_rules = {}
    for lhs, rhs in rules:
        if lhs not in cnf_rules:
            cnf_rules[lhs] = []
        cnf_rules[lhs].append(rhs)
    
    n = len(sentence)
    
    # Create parse table (triangular matrix)
    table = [[set() for _ in range(n - i)] for i in range(n)]
    
    # Fill the first row (diagonal elements)
    for i in range(n):
        word = sentence[i]
        # Find all non-terminals that can produce this terminal
        for lhs, rhs_list in cnf_rules.items():
            for rhs in rhs_list:
                if len(rhs) == 1 and rhs[0] == word:
                    table[0][i].add(lhs)
    
    # Fill the remaining cells using dynamic programming
    for length in range(2, n + 1):  # length of substring
        for i in range(n - length + 1):  # starting position
            j = i + length - 1  # ending position
            
            # Try all possible partitions
            for k in range(i + 1, j):
                # For each partition (i,k) and (k+1,j)
                for lhs, rhs_list in cnf_rules.items():
                    for rhs in rhs_list:
                        if len(rhs) == 2:  # Production of form A -> BC
                            B, C = rhs[0], rhs[1]
                            if B in table[k-i][i] and C in table[j-k][k+1]:
                                table[length-1][i].add(lhs)
    
    # Check if start symbol can generate the entire sentence
    start_symbol = grammar.get('start', 'S')
    can_parse = start_symbol in table[n-1][0]
    
    return can_parse, table

def print_parse_table(table, sentence):
    """
    Print the CYK parse table in a readable format
    """
    n = len(sentence)
    print("CYK Parse Table:")
    print("=" * 50)
    
    for i, row in enumerate(table):
        # Print row number and spacing
        if i == 0:
            print(f"Row {i}: ", end="")
        else:
            print(f"Row {i}: {' ' * (2*i)}", end="")
        
        # Print symbols in this row
        for j, symbols in enumerate(row):
            if symbols:
                print(f"[{', '.join(sorted(symbols))}]", end=" ")
            else:
                print("[ ]", end=" ")
        print()
    print("=" * 50)

# Example usage
if __name__ == "__main__":
    
    # Define a grammar in CNF (Context-Free Normal Form)
    # S -> AB | BC
    # A -> BA | a
    # B -> CC | b
    # C -> AB | a
    
    grammar = {
        'rules': [
            ('S', ['A', 'B']),  # S -> AB
            ('S', ['B', 'C']),  # S -> BC
            ('A', ['B', 'A']),  # A -> BA
            ('A', ['a']),       # A -> a
            ('B', ['C', 'C']),  # B -> CC
            ('B', ['b']),       # B -> b
            ('C', ['A', 'B']),  # C -> AB
            ('C', ['a'])        # C -> a
        ],
        'start': 'S'
    }
    
    # Test sentence
    sentence = ['a', 'b', 'a', 'b']
    
    print("Grammar Rules:")
    for lhs, rhs in grammar['rules']:
        print(f"  {lhs} -> {' '.join(rhs)}")
    print()
    
    print(f"Testing sentence: {' '.join(sentence)}")
    print()
    
    # Parse the sentence
    can_parse, table = cyk_parse(grammar, sentence)
    
    if can_parse:
        print("✓ Sentence can be parsed by the grammar!")
    else:
        print("✗ Sentence cannot be parsed by the grammar.")
    
    print()
    print_parse_table(table, sentence)
    
    # Additional example with a simpler grammar
    print("\n" + "="*60)
    print("SIMPLE EXAMPLE:")
    print("="*60)
    
    simple_grammar = {
        'rules': [
            ('S', ['A', 'B']),  # S -> AB
            ('A', ['a']),       # A -> a
            ('B', ['b'])        # B -> b
        ],
        'start': 'S'
    }
    
    simple_sentence = ['a', 'b']
    
    print("Grammar Rules:")
    for lhs, rhs in simple_grammar['rules']:
        print(f"  {lhs} -> {' '.join(rhs)}")
    print()
    
    print(f"Testing sentence: {' '.join(simple_sentence)}")
    print()
    
    can_parse_simple, table_simple = cyk_parse(simple_grammar, simple_sentence)
    
    if can_parse_simple:
        print("✓ Sentence can be parsed by the grammar!")
    else:
        print("✗ Sentence cannot be parsed by the grammar.")
    
    print()
    print_parse_table(table_simple, simple_sentence)
```

## Output Example

```
Grammar Rules:
  S -> A B
  S -> B C
  A -> B A
  A -> a
  B -> C C
  B -> b
  C -> A B
  C -> a

Testing sentence: a b a b

✓ Sentence can be parsed by the grammar!

CYK Parse Table:
==================================================
Row 0: [A] [B] [A] [B] 
Row 1: [S] [S] [S] 
Row 2: [S] [S] 
Row 3: [S] 
==================================================

============================================================
SIMPLE EXAMPLE:
============================================================
Grammar Rules:
  S -> A B
  A -> a
  B -> b

Testing sentence: a b

✓ Sentence can be parsed by the grammar!

CYK Parse Table:
==================================================
Row 0: [A] [B] 
Row 1: [S] 
==================================================
```

## How CYK Works

1. **Initialization**: Fill the first diagonal of the table with non-terminals that can produce each terminal
2. **Dynamic Programming**: For substrings of increasing length, check if any production can be applied to partition the substring
3. **Result**: The top-right cell contains all non-terminals that can generate the entire sentence

## Time and Space Complexity

- **Time Complexity**: O(n³ × |G|) where n is the sentence length and |G| is the grammar size
- **Space Complexity**: O(n² × |N|) where |N| is the number of non-terminals

The CYK algorithm is particularly useful for parsing context-free grammars and is foundational in natural language processing applications.

